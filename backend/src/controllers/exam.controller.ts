import type { Request, Response } from 'express'
import { z } from 'zod'
import { exams, patients, createExam as createExamRecord } from '@data/mockDb'
import { ok, fail } from '@utils/response'

const createExamSchema = z.object({
  patientId: z.string(),
  type: z.enum(['Radiology', 'Lab', 'Pathology']),
  modality: z.string(),
  status: z.enum(['pending', 'in_review', 'completed', 'requires_attention']).default('pending'),
  orderedBy: z.string(),
  files: z
    .array(
      z.object({
        name: z.string(),
        type: z.enum(['dicom', 'image', 'lab']),
        size: z.string()
      })
    )
    .default([])
})

const analyzeSchema = z.object({
  recommendations: z.array(z.string()).optional()
})

export function listExams(req: Request, res: Response) {
  const { status } = req.query
  let filtered = exams

  if (status && typeof status === 'string') {
    filtered = filtered.filter((exam) => exam.status === status)
  }

  const payload = filtered.map((exam) => ({
    ...exam,
    patient: patients.find((patient) => patient.id === exam.patientId) || null
  }))

  return res.json(ok(payload))
}

export function getExam(req: Request, res: Response) {
  const exam = exams.find((item) => item.id === req.params.id)
  if (!exam) {
    return res.status(404).json(fail('Exam not found', 'EXAM_NOT_FOUND'))
  }

  const patient = patients.find((item) => item.id === exam.patientId) || null
  return res.json(ok({ ...exam, patient }))
}

export function createExam(req: Request, res: Response) {
  const parsed = createExamSchema.safeParse(req.body)
  if (!parsed.success) {
    return res.status(400).json(fail('Invalid exam payload', 'VALIDATION_ERROR'))
  }

  const payload = parsed.data
  const patient = patients.find((item) => item.id === payload.patientId)
  if (!patient) {
    return res.status(404).json(fail('Patient not found', 'PATIENT_NOT_FOUND'))
  }

  const newExam = createExamRecord({
    patientId: payload.patientId,
    type: payload.type,
    modality: payload.modality,
    status: payload.status,
    orderedBy: payload.orderedBy,
    files: payload.files.map((file) => ({
      id: `${Date.now()}-${file.name}`,
      uploadedAt: new Date().toISOString(),
      ...file
    }))
  })

  return res.status(201).json(ok(newExam))
}

export function analyzeExam(req: Request, res: Response) {
  const exam = exams.find((item) => item.id === req.params.id)
  if (!exam) {
    return res.status(404).json(fail('Exam not found', 'EXAM_NOT_FOUND'))
  }

  const parsed = analyzeSchema.safeParse(req.body ?? {})
  if (!parsed.success) {
    return res.status(400).json(fail('Invalid analysis payload', 'VALIDATION_ERROR'))
  }

  const recommendations = parsed.data.recommendations ?? [
    'Discuss findings with supervising physician',
    'Schedule follow-up imaging within 30 days'
  ]

  const confidence = 0.65 + Math.random() * 0.25
  exam.status = 'in_review'
  exam.aiResult = {
    primaryDiagnosis: `AI-assisted insight for ${exam.modality}`,
    secondaryDiagnoses: [
      { label: 'No critical anomalies detected', confidence: Math.max(0.4, confidence - 0.2) },
      { label: 'Recommend manual review of regions of interest', confidence: Math.max(0.3, confidence - 0.25) }
    ],
    confidenceScore: Number(confidence.toFixed(2)),
    recommendations,
    notes: 'Generated by SAM-Vision mock service. Awaiting clinician confirmation.'
  }

  return res.json(ok(exam))
}

export function createExamForPatient(req: Request, res: Response) {
  const patientId = req.params.id
  if (!patientId) {
    return res.status(400).json(fail('Patient id is required', 'VALIDATION_ERROR'))
  }
  const parsed = createExamSchema.safeParse({ ...req.body, patientId })
  if (!parsed.success) {
    return res.status(400).json(fail('Invalid exam payload', 'VALIDATION_ERROR'))
  }

  const patient = patients.find((item) => item.id === patientId)
  if (!patient) {
    return res.status(404).json(fail('Patient not found', 'PATIENT_NOT_FOUND'))
  }

  const payload = parsed.data
  const newExam = createExamRecord({
    patientId,
    type: payload.type,
    modality: payload.modality,
    status: payload.status,
    orderedBy: payload.orderedBy,
    files: payload.files.map((file) => ({
      id: `${Date.now()}-${file.name}`,
      uploadedAt: new Date().toISOString(),
      ...file
    }))
  })

  return res.status(201).json(ok(newExam))
}
