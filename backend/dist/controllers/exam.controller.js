"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.listExams = listExams;
exports.getExam = getExam;
exports.createExam = createExam;
exports.analyzeExam = analyzeExam;
exports.createExamForPatient = createExamForPatient;
const zod_1 = require("zod");
const mockDb_1 = require("@data/mockDb");
const response_1 = require("@utils/response");
const createExamSchema = zod_1.z.object({
    patientId: zod_1.z.string(),
    type: zod_1.z.enum(['Radiology', 'Lab', 'Pathology']),
    modality: zod_1.z.string(),
    status: zod_1.z.enum(['pending', 'in_review', 'completed', 'requires_attention']).default('pending'),
    orderedBy: zod_1.z.string(),
    files: zod_1.z
        .array(zod_1.z.object({
        name: zod_1.z.string(),
        type: zod_1.z.enum(['dicom', 'image', 'lab']),
        size: zod_1.z.string()
    }))
        .default([])
});
const analyzeSchema = zod_1.z.object({
    recommendations: zod_1.z.array(zod_1.z.string()).optional()
});
function listExams(req, res) {
    const { status } = req.query;
    let filtered = mockDb_1.exams;
    if (status && typeof status === 'string') {
        filtered = filtered.filter((exam) => exam.status === status);
    }
    const payload = filtered.map((exam) => ({
        ...exam,
        patient: mockDb_1.patients.find((patient) => patient.id === exam.patientId) || null
    }));
    return res.json((0, response_1.ok)(payload));
}
function getExam(req, res) {
    const exam = mockDb_1.exams.find((item) => item.id === req.params.id);
    if (!exam) {
        return res.status(404).json((0, response_1.fail)('Exam not found', 'EXAM_NOT_FOUND'));
    }
    const patient = mockDb_1.patients.find((item) => item.id === exam.patientId) || null;
    return res.json((0, response_1.ok)({ ...exam, patient }));
}
function createExam(req, res) {
    const parsed = createExamSchema.safeParse(req.body);
    if (!parsed.success) {
        return res.status(400).json((0, response_1.fail)('Invalid exam payload', 'VALIDATION_ERROR'));
    }
    const payload = parsed.data;
    const patient = mockDb_1.patients.find((item) => item.id === payload.patientId);
    if (!patient) {
        return res.status(404).json((0, response_1.fail)('Patient not found', 'PATIENT_NOT_FOUND'));
    }
    const newExam = (0, mockDb_1.createExam)({
        patientId: payload.patientId,
        type: payload.type,
        modality: payload.modality,
        status: payload.status,
        orderedBy: payload.orderedBy,
        files: payload.files.map((file) => ({
            id: `${Date.now()}-${file.name}`,
            uploadedAt: new Date().toISOString(),
            ...file
        }))
    });
    return res.status(201).json((0, response_1.ok)(newExam));
}
function analyzeExam(req, res) {
    const exam = mockDb_1.exams.find((item) => item.id === req.params.id);
    if (!exam) {
        return res.status(404).json((0, response_1.fail)('Exam not found', 'EXAM_NOT_FOUND'));
    }
    const parsed = analyzeSchema.safeParse(req.body ?? {});
    if (!parsed.success) {
        return res.status(400).json((0, response_1.fail)('Invalid analysis payload', 'VALIDATION_ERROR'));
    }
    const recommendations = parsed.data.recommendations ?? [
        'Discuss findings with supervising physician',
        'Schedule follow-up imaging within 30 days'
    ];
    const confidence = 0.65 + Math.random() * 0.25;
    exam.status = 'in_review';
    exam.aiResult = {
        primaryDiagnosis: `AI-assisted insight for ${exam.modality}`,
        secondaryDiagnoses: [
            { label: 'No critical anomalies detected', confidence: Math.max(0.4, confidence - 0.2) },
            { label: 'Recommend manual review of regions of interest', confidence: Math.max(0.3, confidence - 0.25) }
        ],
        confidenceScore: Number(confidence.toFixed(2)),
        recommendations,
        notes: 'Generated by SAM-Vision mock service. Awaiting clinician confirmation.'
    };
    return res.json((0, response_1.ok)(exam));
}
function createExamForPatient(req, res) {
    const patientId = req.params.id;
    if (!patientId) {
        return res.status(400).json((0, response_1.fail)('Patient id is required', 'VALIDATION_ERROR'));
    }
    const parsed = createExamSchema.safeParse({ ...req.body, patientId });
    if (!parsed.success) {
        return res.status(400).json((0, response_1.fail)('Invalid exam payload', 'VALIDATION_ERROR'));
    }
    const patient = mockDb_1.patients.find((item) => item.id === patientId);
    if (!patient) {
        return res.status(404).json((0, response_1.fail)('Patient not found', 'PATIENT_NOT_FOUND'));
    }
    const payload = parsed.data;
    const newExam = (0, mockDb_1.createExam)({
        patientId,
        type: payload.type,
        modality: payload.modality,
        status: payload.status,
        orderedBy: payload.orderedBy,
        files: payload.files.map((file) => ({
            id: `${Date.now()}-${file.name}`,
            uploadedAt: new Date().toISOString(),
            ...file
        }))
    });
    return res.status(201).json((0, response_1.ok)(newExam));
}
//# sourceMappingURL=exam.controller.js.map